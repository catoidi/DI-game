//zscript_DI/ui/unlock/menu.zsc

class DI_UnlockMenu : boxparty_ZF_GenericMenu
{
	DI_UnlockMenuHandler handler;
	
	cvar tutcvar, //check to see if player has done tutorial yet.
		 cheatmode, //force everything to be enabled when cheatmode is on.
		 blacklistcvar, //the cvar containing everything that's blacklisted.
		 morebuttoncvar;
		 
	bool justkeyed; //keyboard was pressed this tic.
	int keypos, curkey; //more keyboard stuff.
	
	Font smallfont;
	
	boxparty_ZF_BoxImage background, 
						 topimage, //the title of the menu at the top left.
					     keyboardselect; //the item selected via keyboard.
	boxparty_ZF_BoxImage currentsprite; //the item sprite shown at the top right of the screen. should be a duplicate of the current buttonimage.
	
	string infotext, //the text that appears at the top when you do something.
		   unlockcounter; //text showing how many unlocks you have so far.
		   
	boxparty_ZF_Label infolabel; //the label containing the infotext.
	
	Array<string> unlocklist; //all the data from the DIUNLOCK file.
	Array<boxparty_ZF_BoxImage> buttonimage, backimage; //the background image and sprite for the buttons.
	Array<boxparty_ZF_Button> buttonlist; //the actual buttons you click.
	
	bool unlockscreated; 
	bool morebuttons; //display 60 buttons at once instead of 15.
	int pagenum; //current page of unlocks.
	
	playerinfo plr;
	
	override void init(menu parent)
	{
		//beginning setup
		super.init(parent);
		setbaseresolution((640, 400));
		smallfont = Font.GetFont("smallfont");
		plr = players[consoleplayer];
		morebuttoncvar = cvar.getcvar("di_unlock_morebuttons", plr);
		if (morebuttoncvar.GetBool() == true) {morebuttons = true;}
		//make background texture
		let bgtex = boxparty_ZF_BoxTextures.CreateTexturePixels("graphics/hat/HATBACK.png", (0, 0), (640, 400), true, true);
		background = boxparty_ZF_BoxImage.Create((0, 0), (640, 400), bgtex, (2, 2));
		background.Pack(mainFrame);
		//make unlocks texture
		let toptex = boxparty_ZF_BoxTextures.CreateTexturePixels("graphics/M_UNLOCK.png", (0, 0), (200, 52), true, true);
		topimage = boxparty_ZF_BoxImage.Create((40, 30), (200, 52), toptex, (2, 2));
		topimage.Pack(mainFrame);
		//create handler
		handler = new('DI_UnlockMenuHandler');
		handler.link = self;
		//keyboard stuff
		keypos = -1;
		curkey = -1;
		//create info label
		infotext = "Select an item to get started.";
		UpdateInfoLabel();
		//parse DIUNLOCK data
		ParseDIUNLOCK();
		//create unlock buttons
		UpdateUnlocks();
		//create page buttons
		CreatePageButtons();
	}
	
	virtual void UpdateInfoLabel()
	{	
		if (mainframe.indexofelement(infolabel) == mainframe.elementcount())
		{
			// Add a label.
			infolabel = boxparty_ZF_Label.Create
			(
				// Position
				(40, 88),
				// Size.
				(0, smallfont.getheight()),
				// The label's text
				text: infotext,
				// The font to use
				fnt: smallfont,
				// Whether to automatically wrap the text or not
				wrap: false,
				// Whether to automatically resize the element based on the text width
				autoSize: true,
				//make the text smaller :)
				textScale: 1.0,
				// The text's colour
				textColor: Font.CR_WHITE
			);
			infolabel.Pack(mainFrame);
		}
		else {infolabel.setText(infotext);}
	}
	
	virtual void ParseDIUNLOCK()
	{
		array<string> filedata;
	
		int ThisLump = Wads.FindLump("DIUNLOCK", 0, Wads.ANYNAMESPACE);
		int NextLump = Wads.FindLump("DIUNLOCK", ThisLump + 1, Wads.ANYNAMESPACE);
		
		while (ThisLump != -1)
		{
			Wads.ReadLump(ThisLump).Split(filedata, "\n", TOK_SKIPEMPTY);
			ThisLump = NextLump;
			NextLump = Wads.FindLump("DIUNLOCK", ThisLump + 1, 1);
		}
		
		for (int i = 0; i < filedata.Size(); ++i)
		{
			if (filedata[i].Left(2) == ">>") {continue;} //comment
			if (filedata[i].Length() < 3) {continue;} //too small
			int linesize = filedata[i].IndexOf(";"); //end of line
			filedata[i] = filedata[i].Left(linesize); //only use data left of the ;
			array<string> curline;
			filedata[i].Split(curline, " ");
			if ((curline.Size() < 2) && (curline.Size() > 3)) {continue;} //each valid line must contain 2 or 3 arguments.
			unlocklist.Push(filedata[i]);
			//console.printf("%s", filedata[i]);
		}
	}
	
	virtual void UpdateUnlocks()
	{
		int maxbuttons = 15;
		int maxcolumn = 3;
		double buttonscale = 2.0;
		if (morebuttons == true)
		{
			maxbuttons = 60;
			maxcolumn = 6;
			buttonscale = 1.0;
		}
		
		if (unlockscreated == false)
		{	
			for (int i = 0; i < maxbuttons; ++i)
			{
				let startx = 24 + ((46 * (i / maxcolumn)) * buttonscale);
				let starty = 112 + ((46 * (i % maxcolumn)) * buttonscale);
				let startx_img = startx - (2 * buttonscale);
				let starty_img = starty - (2 * buttonscale);
				//console.printf("%d, %d", startx, starty);
				
				//CHOOSE BUTTON MODE
				int buttonmode = 0; //item is locked
				array<string> curline;
				if (i >= unlocklist.Size()) {buttonmode = -1;} //item is missing
				else
				{
					//console.printf("%s", "getting cvar #%d", i);
					unlocklist[i].Split(curline, " ");
					cvar curcvar = cvar.getcvar(curline[0], plr);
					
					if (curcvar && (curcvar.GetBool())) {buttonmode = 1;} //item is unlocked
				}
				
				//CREATE THE BACKGROUND IMAGE
				let backimg = "graphics/hat/HATMISSING.png";
				switch(buttonmode)
				{
					case 0: backimg = "graphics/hat/DILOCK.png"; break;
					case 1: backimg = "graphics/hat/HATBLANK4.png"; break;
				}
				let curtex = boxparty_ZF_BoxTextures.CreateSingleTexture(backimg, false);
				let curboximage = boxparty_ZF_BoxImage.Create
				(
					// Position
					(startx_img, starty_img),
					// Size
					(44 * buttonscale, 44 * buttonscale),
					// Texture
					curtex,
					// Scale
					(buttonscale, buttonscale)
				);
				backimage.Push(curboximage);
				curboximage.Pack(mainFrame);
				
				//CREATE THE UNLOCKED IMAGE
				let unlockimg = 'graphics/hat/HATIDLE.png';
				vector2 iconsize = (44, 44);
				float bonusx, bonusy = 0;
				float sizescale = 1.0;
				if (buttonmode == 1)
				{
					unlockimg = string.format('graphics/unlocks/%s.png', curline[0]);
					let temptex = texman.checkfortexture(unlockimg);
					if (temptex.IsValid())
					{
						float sizex, sizey;
						[sizex, sizey] = TexMan.GetSize(temptex);
						if (sizex == 0) {sizex = 1;} //do not divide by 0 pls thank u :)
						if (sizey == 0) {sizey = 1;}
						sizescale = (32 * buttonscale) / sizex; //get scale from X
						float sizescaley = (32 * buttonscale) / sizey; //get scale from Y
						if (sizescaley > sizescale) {sizescale = sizescaley;} //just pick whichever one is largest and scale based off that.
						if (sizescale > (3.0 * buttonscale)) {sizescale = (3.0 * buttonscale);} //default size is 3x.
						sizex *= sizescale;
						sizey *= sizescale;
						iconsize = (sizex, sizey);
						bonusx = ((40 * buttonscale) - sizex) / 2;
						bonusy = ((40 * buttonscale) - sizey) / 2; //place texture in the center of the whitespace.
						//console.printf("%s, %s\n%d+%d, %d+%d\n%.1f, %.1f, %.1f", curline[0], unlockimg, startx, bonusx, starty, bonusy, sizex, sizey, sizescale);
					}
					else {unlockimg = 'graphics/hat/HATIDLE.png';}
				}
				let curtex2 = boxparty_ZF_BoxTextures.CreateTexturePixels(unlockimg, (0, 0), iconsize, true, true);
				let curboximage2 = boxparty_ZF_BoxImage.Create
				(
					// Position
					(startx + bonusx, starty + bonusy),
					// Size
					iconsize,
					// Texture
					curtex2,
					// Scale
					(sizescale, sizescale)
				);
				buttonimage.Push(curboximage2);
				curboximage2.Pack(mainFrame);
				
				let docommand = "sorrynothing";
				if (buttonmode == 0) {docommand = string.format("LOCKED:%s", curline[0]);}
				else if (buttonmode == 1) {docommand = string.format("UNLOCKED:%s", curline[0]);}
				//CREATE THE BUTTON ITSELF
				let buttonIdle = boxparty_ZF_BoxTextures.CreateSingleTexture ("graphics/hat/HATIDLE.png", true);
				let buttonHover = boxparty_ZF_BoxTextures.CreateSingleTexture ("graphics/hat/HATHOVER.png", true);
				let buttonClick = boxparty_ZF_BoxTextures.CreateSingleTexture ("graphics/hat/HATSELECT.png", true);
				// Add a button.
				//console.printf("%s", docommand);
				let curbutton = boxparty_ZF_Button.Create
				(
					// Position
					(startx, starty),
					// Size
					(40 * buttonscale, 40 * buttonscale),
					// Our command handler
					cmdHandler: handler,
					// A command string for the button
					command: docommand,
					// The button's textures
					inactive: buttonIdle,
					hover: buttonHover,
					click: buttonClick
				);
				// Add the button element into the main frame.
				buttonlist.Push(curbutton);
				curbutton.Pack (mainFrame);
			}
		}
	}
	
	virtual void CreatePageButtons()
	{
		
	}
}