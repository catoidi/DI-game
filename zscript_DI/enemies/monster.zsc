Class DI_Monster : DI_Actor abstract
{
	String coindrop;
	property DIDrop: coindrop;
	PlayerPawn plrtarget;
	
	int painhp; //health value since a_dipain was last called.
	double icenum; //how much ice slowdown to apply.
	int firenum; //how much the enemy is currently on fire.
	int poisonnum; //how much the enemy has been poisoned.
	bool isshocked; //enemy is currently shocked. does not affect the monster in anyway. use this to know if monster is shocked or not.
	int ticker; //a timer.
	int poisonticker; //extra delay for poison effect.
	bool hearted; //whether or not this monster has been hit with a heart attack.
	bool friendlylight; //enable/disable the hearted light.
	int hearttimer; //how long to keep the enemy charmed.
	double speedmult; //speed multiplier.
	property DISpeedMult: speedmult;

	//Called by all of DI's enemies.
	Default
	{
		Mass 100;
		PainChance 256;
		PainChance "Heart", 256;
		Monster;
		DamageFactor "Enemy", 0;
		DamageFactor "FakeLightning", 1.0; //fake damagetypes only hurt enemies, not players. if i knew a better way of doing this, i would swap this out with that in a heartbeat.
		DamageFactor "FakeIce", 1.0;
		DamageFactor "FakeFire", 1.0;
		DamageFactor "FakePoison", 1.0;
		PainSound "dipain2";
		DeathSound "dipain";
		Species "Enemy";
		DI_Monster.DIDrop "DI_Coin";
		DI_Monster.DISpeedMult 1.0;
		+THRUSPECIES; //monsters of the same type can walk through each other.
		+FLOORCLIP;
		+JUMPDOWN;
		+CASTSPRITESHADOW;
		+NOINFIGHTING;
		+LOOKALLAROUND;
		
		//$Category "DI/Enemies/"
		//$Color 4
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		A_SpawnItemEX("DIMarker", flags: SXF_NOCHECKPOSITION | SXF_SETTARGET | SXF_TRANSFERSPRITEFRAME | SXF_ISTARGET);
		
		AdjustPainThreshold();
		painhp = health;
		speed = default.speed * speedmult;
	}
	
	override void Tick(void)
	{
		Super.Tick();
	
		if ((target) && (target is "PlayerPawn"))
		{
			plrtarget = PlayerPawn(target);
		}
		
		++ticker;
		if ((ticker >= 20) && (health > 0))
		{
			if (icenum > 0) {A_DIIced(2, 0.15);}
			UpdateIceNum(-0.01);
			
			if ((firenum == 0) && (poisonnum == 0)) {A_DIStatusLight(0);}
			
			if (firenum > 0)
			{
				int firedmg = 3 + (firenum / 2);
				if (firedmg > firenum) {firedmg = firenum;}
				
				A_DIBurned(2, 0.5);
				A_DIStatusLight(2);
				
				if (self.health <= firedmg) {A_Die("Fire");}
				else {self.health -= firedmg; A_Pain();}
				firenum -= firedmg;
				if (firenum < 0) {firenum = 0;}
			}
			
			++poisonticker;
			if ((poisonnum > 0) && (poisonticker > 2))
			{
				int poisondmg = poisonnum / 5;
				if (poisondmg < 1) {poisondmg = 1;}
				
				A_DIPoisoned(2, 0.5);
				if (firenum <= 0) {A_DIStatusLight(3);}
				
				if (self.health <= poisondmg) {A_Die("Poison");}
				else {self.health -= poisondmg; A_Pain();}
				poisonnum -= poisondmg;
				if (poisonnum < 0) {poisonnum = 0;}
				
				poisonticker = 0;
			}
			
			if (hearttimer > 0) {--hearttimer;}
			else {hearted = false;}
			if (hearted == true) 
			{
				DoCharmEffect();
			}
			else if (friendlylight == true) 
			{
				bFRIGHTENED = false;
				DamageMultiply += 0.66;
				friendlylight = false;
				A_RemoveLight("friendlylight");
			}
			
			ticker = 0;
		}
	}
	
	override void Die(Actor source, Actor inflictor, int dmgflags, Name MeansOfDeath)
	{
		//console.printf("%s", inflictor.GetClassName());
		
		if (inflictor is "DI_Actor")
		{
			DI_Actor dicheck = DI_Actor(inflictor);
			if (dicheck.di_notweapon == true)
			{
				di_notweapon = true; //this monster did not die from a weapon.
			}
		}
	
		Super.Die(source, inflictor, dmgflags, MeansOfDeath);
	}
	
	virtual void AdjustPainThreshold(void)
	{
		//overwrite this function if you want manual control over PainThreshold.
		PainThreshold = (Health / 30) - 1;
		if (PainThreshold < 1) {PainThreshold = 1;}
	}
	
	virtual void UpdateIceNum(double iceamount)
	{
		icenum += iceamount;
		if (icenum > 0.9) {icenum = 0.9;}
		else if (icenum < 0) {icenum = 0.0;}
		
		speed = default.speed * speedmult * (1.0 - icenum);
	}
	
	virtual void DoCharmEffect(void)
	{
		A_DIHearted(2, 1.0);
		bFRIGHTENED = true;
		if (friendlylight == false)
		{
			DamageMultiply -= 0.66;
			int size1 = radius;
			int size2 = size1 * 0.75;
			int lightoffset = height / 2;
			A_AttachLight("friendlylight", DynamicLight.PointLight, Color(0xd2a5ff), size1, size2, 0, (0, 0, lightoffset), 0.1);
			friendlylight = true;
		}
	}
	
	action void A_DITargetPlayer(void)
	{
		//ensures that the enemy drops are calculated based on whichever player it was targetting last.
		if (invoker.plrtarget != null)
		{
			target = Actor(invoker.plrtarget);
		}
	}
	
	action void A_DIIcePain(double fakedmg = 0.0)
	{
		//called before A_DIPain.
		//slows the enemy speed based on how much damage they took from the ice attack.
		double icepain = (invoker.painhp - invoker.health) * 2;
		if (fakedmg != 0.0) {icepain = fakedmg;} //ignore damage taken, use preset value instead.
		icepain *= 1.0 / invoker.default.health;
		int iceparticle = icepain * 6;
		invoker.UpdateIceNum(icepain);
		invoker.A_DIIced(iceparticle, 0.15);
	}
	
	action void A_DIFirePain(int fakedmg = 0)
	{
		int firepain = (invoker.painhp - invoker.health); //fire effect will effectively double the damage given.
		if (fakedmg != 0) {firepain = fakedmg;} //ignore damage taken, use preset value instead.
		int fireparticle = 5 + (firepain / 25);
		invoker.firenum += firepain;
		invoker.A_DIBurned(fireparticle, 0.5);
		invoker.A_DIStatusLight(2);
	}
	
	action void A_DIPoisonPain(int fakedmg = 0)
	{
		int poisonpain = (invoker.painhp - invoker.health) * 3; //poison damage gives a strong DOT effect, but is slower than fire.
		if (fakedmg != 0) {poisonpain = fakedmg;} //ignore damage taken, use preset value instead.
		int poisonparticle = 5 + (poisonpain / 25);
		invoker.poisonnum += poisonpain;
		invoker.A_DIPoisoned(poisonparticle, 0.5);
		invoker.A_DIStatusLight(3);
	}
	
	action void A_DIHeartPain(void)
	{
		if (random(1, invoker.PainThreshold) <= 1)
		{
			invoker.hearted = true;
			invoker.hearttimer += 8;
			invoker.DoCharmEffect();
		}
		else
		{
			invoker.A_DIPoisonPain(invoker.PainThreshold * 10);
		}
	}
	
	action void A_DIPain(void)
	{
		if ((invoker.firenum == 0) && (invoker.poisonnum == 0)) {A_DIStatusLight(0);} //remove any lingering status lights if there's not status effect active.
		invoker.isshocked = false;
	
		int thrustnum = 1 + (((invoker.painhp - invoker.health) * 25) / invoker.default.health);
		ThrustThingZ(0, thrustnum, 0, 1);
		invoker.painhp = invoker.health;
		A_Pain();
	}
	
	States
	{
		Pain:
			#### # 10 A_DIPain();
			#### # 0 A_ResetScale();
			#### # 0 A_Jump(256, "See");
			Stop;
		Pain.Melee:
			#### # 30 A_DIPain();
			#### # 0 A_ResetScale();
			#### # 0 A_Jump(256, "See");
			Stop;
		Pain.FakeLightning:
			#### # 0 A_Jump(256, "Pain.Lightning");
			Stop;
		Pain.Lightning:
			#### ### 0 A_DIShocked();
			#### # 60 {A_DIPain(); A_DIStatusLight(1); invoker.isshocked = true;}
			#### # 0 A_ResetScale();
			#### # 0 A_DIStatusLight(0);
			#### # 0 {invoker.isshocked = false;}
			#### # 0 A_Jump(256, "See");
			Stop;
		Pain.FakeIce:
			#### # 0 A_Jump(256, "Pain.Ice");
			Stop;
		Pain.Ice:
			#### # 0 A_DIIcePain();
			#### # 0 A_Jump(256, "Pain");
			Stop;
		Pain.FakeFire:
			#### # 0 A_Jump(256, "Pain.Fire");
			Stop;
		Pain.Fire:
			#### # 0 A_DIFirePain();
			#### # 0 A_Jump(256, "Pain");
		Pain.FakePoison:
			#### # 0 A_Jump(256, "Pain.Poison");
			Stop;
		Pain.Poison:
			#### # 0 A_DIPoisonPain();
			#### # 0 A_Jump(256, "Pain");
		Pain.Heart:
			#### # 0 A_DIHeartPain();
			#### # 0 A_Jump(256, "Pain");
		Death:
			#### # 0 A_DITargetPlayer();
			#### # 0 A_DIDie();
			#### ### 0 A_DIDieBlood();
			Goto DeathLoop;
		DeathLoop:
			#### # 1 
			{
				A_DIScale(1.01, 0.95, true);
				A_FadeOut(0.03);
			}
			Loop;
		Death.FakeLightning:
			#### # 0 A_Jump(256, "Death.Lightning");
			Stop;
		Death.Lightning:
			#### # 0 A_Explode(5, invoker.radius + 32, XF_NOTMISSILE | XF_EXPLICITDAMAGETYPE, 0, 32678, damagetype: "FakeLightning");
			#### # 0 A_QuakeEX(1, 1, 1, 10, 0, invoker.radius + 32, 0);
			#### # 0 A_AttachLightDef("deathlight", "SHOCKER");
			#### ##### 0 A_DIShocked(2.0);
			#### # 0 A_Jump(256, "Death");
			Stop;
		Death.FakeIce:
			#### # 0 A_Jump(256, "Death.Ice");
			Stop;
		Death.Ice:
			#### # 0 
			{
				A_SetTranslation("Ice");
				A_DIIced(16, 0.5, true);
				A_DIDie();
				A_DIDieBlood();
				A_SpawnItemEx(invoker.coindrop, random(-8, 8), random(-8, 8), random(8, 16), random(-2, 2), random(-2, 2), random(6, 10), 0, SXF_TRANSFERTRANSLATION | SXF_TRANSFERPOINTERS | SXF_NOCHECKPOSITION);
				A_SpawnItemEx(invoker.coindrop, random(-8, 8), random(-8, 8), random(8, 16), random(-2, 2), random(-2, 2), random(6, 10), 0, SXF_TRANSFERTRANSLATION | SXF_TRANSFERPOINTERS | SXF_NOCHECKPOSITION); //spawn 2 extra coins as a bonus, since ice corpses are kinda annoying to deal with.
			}
			#### # 0 A_FreezeDeath();
			#### # 35 A_FreezeDeathChunks();
			Wait;
	}
}